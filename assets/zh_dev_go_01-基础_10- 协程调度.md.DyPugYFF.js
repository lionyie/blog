import{_ as i,c as e,o,ab as a}from"./chunks/framework.ChIQI1Yf.js";const l="/blog/assets/1716170613815-9aa8805d-f5b1-4574-bd1a-5c6207cec596.Cxv3ucjX.png",n="/blog/assets/1716170613828-deb2a5e6-e58a-4ad4-a5da-39a868ef5e55.Cqm_JZDO.png",t="/blog/assets/1716170613759-9ed16a39-b6b0-4bec-82a7-730cae3bc67e.Ccu0S9Qh.png",r="/blog/assets/1716170614339-bda521b8-1cc2-4fc0-8b1c-c9ff7e929383.CTwA_5CI.png",s="/blog/assets/1716170613880-dec1a2a1-0d1a-4846-af5c-c078d935d0e7.KeorgCpm.png",f=JSON.parse('{"title":"协程调度","description":"","frontmatter":{},"headers":[],"relativePath":"zh/dev/go/01-基础/10- 协程调度.md","filePath":"zh/dev/go/01-基础/10- 协程调度.md","lastUpdated":1716300052000}'),p={name:"zh/dev/go/01-基础/10- 协程调度.md"},u=a('<h1 id="协程调度" tabindex="-1">协程调度 <a class="header-anchor" href="#协程调度" aria-label="Permalink to &quot;协程调度&quot;">​</a></h1><h2 id="_1-调度流程" tabindex="-1">1.调度流程 <a class="header-anchor" href="#_1-调度流程" aria-label="Permalink to &quot;1.调度流程&quot;">​</a></h2><p><img src="'+l+'" alt="img"></p><h2 id="_2-go程序运行和调度初始化" tabindex="-1">2.Go程序运行和调度初始化 <a class="header-anchor" href="#_2-go程序运行和调度初始化" aria-label="Permalink to &quot;2.Go程序运行和调度初始化&quot;">​</a></h2><p>Go 程序运行会经过以下几个阶段：</p><ol><li>从磁盘上读取可执行文件，加载到内存</li><li>操作系统执行 runtime 包中的程序入口</li><li>runtime 执行初始化，最后调用 main 函数</li></ol><p><img src="'+n+'" alt="img"></p><p>上图中的流程是根据源码文件 src/runtime/asm_amd64.s 和 src/runtime/proc.go 而画的，只是大致描述了Go程序运行的流程，对具体细节感兴趣的可以阅读源码了解或亲自反汇编程序了解</p><p>值得注意的是，GMP模型在初始化中的变化：</p><p><img src="'+t+'" alt="img"></p><p>G0是特殊的goroutine，它的栈直接分配到线程栈中，与M直接关联。goroutine 的创建和 goroutine 的调度等任务都在G0上执行。</p><p>至于调度初始化的内容，就在 schedinit() 函数中。</p><p>schedinit() 函数调用了很多函数，程序运行环境的初始化几乎都在这里进行：</p><p><img src="'+r+`" alt="img"></p><h2 id="_3-goroutine状态" tabindex="-1">3.goroutine状态 <a class="header-anchor" href="#_3-goroutine状态" aria-label="Permalink to &quot;3.goroutine状态&quot;">​</a></h2><ul><li>Gidle：空闲状态，表示Goroutine未被调度执行。</li><li>Grunnable：可运行状态，表示Goroutine已经准备好运行，等待被调度到一个线程（M）上执行。</li><li>Grunning：运行状态，表示Goroutine正在一个线程（M）上执行。</li><li>Gsyscall：系统调用状态，表示Goroutine正在执行阻塞的系统调用。</li><li>Gwaiting：等待状态，表示Goroutine正在等待某个事件（如通道操作、同步原语等）。</li><li>Gdead：死亡状态，表示Goroutine已经执行完成或被终止。</li></ul><h2 id="_4-goroutine创建" tabindex="-1">4.goroutine创建 <a class="header-anchor" href="#_4-goroutine创建" aria-label="Permalink to &quot;4.goroutine创建&quot;">​</a></h2><p>goroutine的创建是由 newproc 函数执行，而 newproc 主要做的就是切换到G0栈上去调用 newproc1 函数。</p><p>newproc1 的步骤：</p><ol><li>禁止抢占，并获取当前 goroutine 的 M 和 P</li><li>先从当前 P 和全局队列中获取空闲的 goroutine；如果没有就创建一个 goroutine，并添加到全局变量 allgs 中</li><li>如果 go func() 的函数有参数，就把参数移到 goroutine 栈上</li><li>设置各个寄存器的值，设置pc寄存器值为 &amp;goexit + sys.PCQuantum（sys.PCQuantum 在x86上为1，大多数其他系统上为4），可以理解成将返回地址设为 goexit 的第二条指令。</li><li>调用 gostartcallfn，其主要功能是调用 gostartcall；而 gostartcall 的作用是将goexit 函数入栈，将 goroutine 的函数伪装成是 goexit 调用的，当函数执行完时就会返回 goexit 来清理线程</li><li>设置 goroutine 的状态，调用 runqput，然后把 goroutine 放入p的待执行队列中</li><li>尝试唤起一个P来执行当前 goroutine</li><li>允许抢占</li></ol><p>伪装结果大致如下：</p><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> goexit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    goroutine </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">函数</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//伪装成是 goexit 第一条指令调用的</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    清理现场</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//返回地址就是第二条指令</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="`+s+'" alt="img"></p><h2 id="_5-goroutine切换" tabindex="-1">5.goroutine切换 <a class="header-anchor" href="#_5-goroutine切换" aria-label="Permalink to &quot;5.goroutine切换&quot;">​</a></h2><p>goroutine 的切换一般会在以下几种情况发生：</p><ol><li>基于信号抢占式的调度，一个 goroutine 如果运行很长，会被踢掉</li><li>发生系统调用，系统调用会陷入内核，开销不小，暂时解除当前 goroutine</li><li>channel 阻塞，当从channel读不到或者写不进的时候，会切换 goroutine</li></ol><p>切换就是让出和恢复：</p><h3 id="goroutine让出" tabindex="-1">goroutine让出 <a class="header-anchor" href="#goroutine让出" aria-label="Permalink to &quot;goroutine让出&quot;">​</a></h3><p>通过 runtime.gopark 来实现：</p><ol><li><p>禁止抢占</p></li><li><p>将 Grunning 状态的 goroutine 设置为 Gwaiting</p></li><li><p>允许抢占</p></li><li><p>调用 mcall：</p></li><li><p>保存当前 goroutine 上下文，切换到 G0 栈上</p></li><li><p>调用 runtime.park_m：</p></li><li><p>解除 goroutine 和当前工作线程M的关系</p></li><li><p>调用 schedule 获取一个新 goroutine 来运行</p></li></ol><h3 id="goroutine恢复" tabindex="-1">goroutine恢复 <a class="header-anchor" href="#goroutine恢复" aria-label="Permalink to &quot;goroutine恢复&quot;">​</a></h3><p>通过 runtime.goready 来实现：</p><ol><li><p>切换到 G0 栈上，并执行 runtime.ready：</p></li><li><p>获取goroutine的状态，并禁止抢占</p></li><li><p>将 Gwaiting 状态的 goroutine 切换到 Grunable 状态，放到当前P的本地队列</p></li><li><p>尝试唤起一个P来执行当前 goroutine</p></li><li><p>允许抢占</p></li></ol><p>让出和恢复的源码文件都在：src/runtime/proc.go 中</p><h2 id="_6-goroutine监控" tabindex="-1">6.goroutine监控 <a class="header-anchor" href="#_6-goroutine监控" aria-label="Permalink to &quot;6.goroutine监控&quot;">​</a></h2><p><strong>监控****线程</strong> sysmon 是由 main goroutine 创建的。它很特殊，它不依赖P，也不由GMP模型调度，它会重复执行一系列任务：</p><ol><li>释放闲置的内存减少内存占用</li><li>若距离上次GC已经超过了两分钟，会强制触发GC</li><li>进行 netpool，即对IO事件主动轮询</li><li>针对处于运行中 prunning 或者系统调用 psyscall 状态的P判断是否满足抢占条件，如果满足则进行抢占</li></ol><h2 id="_7-协程抢占" tabindex="-1">7.协程抢占 <a class="header-anchor" href="#_7-协程抢占" aria-label="Permalink to &quot;7.协程抢占&quot;">​</a></h2><p>有两种情况会发生抢占：</p><p><strong>监控抢占</strong></p><p>当 G 阻塞在 M 上时（系统调用、channel 等），系统监控会将 P 从 M 上抢夺并分配给其他的 M 来执行其他的 G，而位于被抢夺 P 的 M 本地调度队列中 的 G 则可能会被偷取到其他 M 中。</p><p><strong>GC抢占</strong></p><p>当需要进行垃圾回收时，为了保证不具备主动抢占处理的函数执行时间过长，导致导致垃圾回收迟迟不得执行而导致的高延迟，而强制停止 G 并转为执行垃圾回收。</p><p>在Go 1.14之前使用的是基于协作的抢占式调度，Go 1.14后使用的是基于信号的抢占式调度</p><p><strong>基于协作的抢占式调度流程</strong>：</p><ul><li>编译器会在调用函数前插入 runtime.morestack，让运行时有机会在这段代码中检查是否需要执行抢占调度</li><li>Go语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms，那么会在这个协程设置一个抢占标记</li><li>当<strong>发生函数调用时</strong>，可能会执行编译器插入的 runtime.morestack，它调用的 runtime.newstack会检查抢占标记，如果有抢占标记就会触发抢占让出cpu，切到调度主协程里</li></ul><p>基于协作的抢占，很明显能看出有问题：当没有发生函数调用，只是纯算法运算的 G，调度器就没办法抢占，只能等待 G 运行结束。而基于信号的抢占，不管G有没有主动让出，都会抢占。</p><p><strong>基于信号的抢占式调度流程</strong>：</p><ul><li>M 注册一个 SIGURG 信号的处理函数：sighandler</li><li>sysmon启动后会间隔性的进行监控，最长间隔10ms，最短间隔20us。如果发现某协程独占P超过10ms，会给M发送抢占信号</li><li>M 收到信号后，内核执行 sighandler 函数把当前协程的状态从_Grunning正在执行改成 _Grunnable可执行，把抢占的协程放到全局队列里，M继续寻找其他 goroutine 来运行</li><li>被抢占的 G 再次调度过来执行时，会继续原来的执行流</li></ul><h2 id="总结和思考" tabindex="-1">总结和思考 <a class="header-anchor" href="#总结和思考" aria-label="Permalink to &quot;总结和思考&quot;">​</a></h2><ul><li>goroutine 的创建、切换和调度都是在G0栈上实现的</li><li>G0 栈分配在线程栈中，与M直接关联，每个M都有对应的 G0</li><li>基于协作和基于信号的抢占式调度的区别，是需不需要G主动让出才能抢占</li></ul><p>一个 Go 程序默认至少有多少 goroutine ？</p><p>答：5个</p><ul><li>main:用户主协程</li><li>forcegchelper:监控计时器触发垃圾回收</li><li>bgsweep:负责垃圾回收的并发执行</li><li>scavenger :负责mhead(堆内存)的回收</li><li>finalizer:专门运行最终附加到对象的所有终结器(Finalizer)</li></ul><p>goroutine 什么时候发生阻塞？</p><p>答：</p><ul><li>阻塞在系统调用：当 goroutine 执行一个阻塞的系统调用（如文件I/O、网络I/O等）时，它会被阻塞，直到系统调用完成。</li><li>阻塞在通道操作：goroutine 在执行通道（channel）操作时，如发送数据到一个已满的通道或从一个空的通道接收数据，可能会发生阻塞。阻塞会持续到通道中有足够的空间或数据可用。</li><li>阻塞在同步原语：goroutine 在等待锁（如sync.Mutex）或其他同步原语（如sync.WaitGroup）时，可能会发生阻塞。</li><li>阻塞在GC：在GC过程中，所有 goroutine 都可能会短暂地被阻塞，以便垃圾回收器完成内存回收。</li></ul><p>P能够存储多少个 goroutine ？</p><p>答：257个；runq队列存储256个，runnext存一个</p><h2 id="写在后面的话" tabindex="-1">写在后面的话 <a class="header-anchor" href="#写在后面的话" aria-label="Permalink to &quot;写在后面的话&quot;">​</a></h2><p>关于协程调度还有很多没有写出来，例如循环调度schedule函数的细节，协程抢占的图示步骤等等，这些东西理解了但是要写出来真是令人绞尽脑汁，作图也是非常繁琐（今天突然发现之前的图背景都是空白，放大看非常难受，有时间再改吧）。本来一开始只是打算快速基础学习，结果学习发散不小心深入了，这些缺的细节之后复习还会再弥补回来的。</p>',61),g=[u];function h(c,d,m,_,b,k){return o(),e("div",null,g)}const P=i(p,[["render",h]]);export{f as __pageData,P as default};
