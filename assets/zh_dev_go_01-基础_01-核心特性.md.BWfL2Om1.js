import{_ as s,c as i,o as a,ab as n}from"./chunks/framework.ChIQI1Yf.js";const p="/blog/assets/1716168516859-e6d773bf-8436-417c-aa68-05a75c2cf7b9.t7VBNQU1.png",l="/blog/assets/1716168517143-753f60f0-fdc4-49d6-8701-180c93d1043d.CriOXY0Y.png",h="/blog/assets/1716168517050-78b69844-af36-45b0-9f96-b851b50e2885.CvL1LNx1.webp",t="/blog/assets/1716168517358-9b699bfc-ca10-4930-8b66-e6cfd8c16e62.CwlY5C4Z.png",e="/blog/assets/1716168517421-9bb1cc13-d62c-43ce-b517-5fcac3891afe.BTyeUeCQ.png",k="data:image/gif;base64,R0lGODlhCwAQAJEAAAAAAP///4CAgP///yH5BAEAAAMALAAAAAALABAAQAIhnI8mId2snBRxtoRV2ItrvkHZSJZd6A3n+jEhpaJvSRsFADs=",r="/blog/assets/1716168517366-2a0bbe4b-7ebe-4feb-a289-a2bc93d52ac0.C6pjFdx1.webp",g="/blog/assets/1716168517561-e922b665-1a8a-4100-9c7d-ce0c6bb1e586.CGqD4QCQ.png",d="/blog/assets/1716168517636-f7c60b18-c0c7-4570-8b72-a03a0c21b17b._pLnn4zY.png",c="/blog/assets/1716168517636-9ccb3d7d-1364-4379-b865-be2924320c65.pBduu43r.webp",o="/blog/assets/1716168517713-4f2e0080-2528-4c3d-9ef5-9dcfd932fd0e.DZVRIfEF.webp",y="/blog/assets/1716168517799-8a635cff-1eba-4b40-8f4c-5b95c880a11e.BofuHTuZ.png",F="/blog/assets/1716168517927-a1e5c170-551c-445d-85dd-66a57114d21a.MaStHbnc.png",b="/blog/assets/1716168517948-99a35c04-de64-4d87-82db-3f49fc234db6.BNbVhAgl.png",E="/blog/assets/1716168517993-3dabc259-cc23-4c51-8652-df631bf4f8a3.MWBE6OWP.png",m="/blog/assets/1716168518121-83aec759-9cbe-4122-8676-1e0f4b2e8f3e.DoymZjyI.png",C="/blog/assets/1716168518047-842dfc28-6836-4145-9c77-c93b51b3f6f5.CRC4HWKM.png",u="/blog/assets/1716168518202-705ebb57-5d53-4f57-81f9-0e2a035e7dff.-mlEHrZP.png",A="/blog/assets/1716168518391-7c32c39f-9e1e-4adc-a79a-22f1e2c0ba76.oZUMgPBF.png",M=JSON.parse('{"title":"Golang核心特性","description":"","frontmatter":{},"headers":[],"relativePath":"zh/dev/go/01-基础/01-核心特性.md","filePath":"zh/dev/go/01-基础/01-核心特性.md","lastUpdated":1716207995000}'),B={name:"zh/dev/go/01-基础/01-核心特性.md"},D=n('<h1 id="golang核心特性" tabindex="-1">Golang核心特性 <a class="header-anchor" href="#golang核心特性" aria-label="Permalink to &quot;Golang核心特性&quot;">​</a></h1><h2 id="_1-并发编程" tabindex="-1">1.并发编程 <a class="header-anchor" href="#_1-并发编程" aria-label="Permalink to &quot;1.并发编程&quot;">​</a></h2><p>不同于传统的多进程或多线程，golang的并发执行单元是一种称为goroutine的协程。其在语言级别提供关键字：</p><ul><li><strong>go</strong>——用于启动协程。</li><li><strong>chan</strong>——golang中用于并发的通道，用于协程的通信。</li><li><strong>select</strong>——golang提供的多路复用机制。</li><li><strong>close()</strong>——golang的内置函数，可以关闭通道。</li><li><strong>sync</strong>——golang标准库之一，提供锁。</li></ul><p>协程经常被理解为轻量级线程，一个线程可以包含多个协程，<strong>共享堆不共享栈</strong>。协程间一般由<strong>应用程序显式实现调度</strong>，上下文切换无需下到内核层，高效不少。</p><p>协程间一般不做同步通讯，而golang中实现协程间通讯有两种：</p><ol><li>共享内存型，即使用全局变量+mutex锁来实现数据共享；</li><li>消息传递型，即使用一种独有的channel机制进行异步通讯。</li></ol><p><strong>高并发是Golang最大的亮点。</strong></p><h2 id="_2-内存管理" tabindex="-1">2.内存管理 <a class="header-anchor" href="#_2-内存管理" aria-label="Permalink to &quot;2.内存管理&quot;">​</a></h2><h3 id="堆内存" tabindex="-1">堆内存 <a class="header-anchor" href="#堆内存" aria-label="Permalink to &quot;堆内存&quot;">​</a></h3><p>Go 的内存分配是参考 <em>TcMalloc</em> 实现的，TCMalloc 的<strong>核心思想</strong>是：</p><ul><li>按照一组预置的大小规格将内存页划分成块，然后把<strong>不同规格的内存块放入对应的空闲链表</strong>中；程序申请内存时，分配器会根据其内存大小找到最匹配的规格，从对应空闲链表分配一个或若干个内存块。</li><li>Go 1.16 runtime包，给出了67种大小规格，最小8B，最大32KB。</li></ul><p>Go 的内存管理是一个金字塔结构，层次如下：</p><p><img src="'+p+`" alt="img"></p><p>接下来逐个分析一下 Go 各个内存分配器的大致结构：</p><ul><li><strong>mspan</strong> —— 是 Go <strong>内存管理的基本单元</strong>，若干个连续的 page 组成一个 mspan。（Go 的一个 page 为 8KB）</li></ul><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 源码文件路径：runtime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mheap.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Line:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">316</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mspan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     next</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // 链表下一个span地址</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     prev</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // 链表前一个span地址</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     list</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mSpanList</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 链表地址 用于调试</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     startAddr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 该span在arena区域的起始地址</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 9</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     npages</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 该span占用arena区域page的数量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     manualFreeList</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> gclinkptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 空闲链表</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     freeindex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 扫描页中空闲对象的初始索引（表明freeindex之前的都被使用）</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     nelems</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // 管理的对象（块）个数，也即有多少个块可供分配。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     allocCache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uint64</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // allocBits 的补码，缓存freeindex开始的bitmap，可以用于快速查找内存中未被使用的内存。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     allocBits</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gcBits</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 该mspan中对象分配位图，每一位代表一个块是否已分配。</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     allocCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  uint16</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 已分配的对象的个数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     spanclass</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   spanClass</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // sizeclass表中的classId</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     needzero</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint8</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 分配之前需要置零</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     elemsize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // sizeclass表中的对象大小，也即块大小</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">22</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     unusedsince</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int64</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 空闲状态开始的纳秒值时间戳，用于系统内存释放</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     limit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 申请大对象内存块会用到，mspan的数据截止位置</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     ......</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>在这一块最主要的是理解 spanclass 和 sizeclass、span 和 object 之间的关系。</p><p>上面我们有说过，Go 的有67种大小规模，以表的形式展现，这其实就是 <strong>sizeclass</strong>。</p><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">源码文件路径：src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">runtime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sizeclasses.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">go</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// class  bytes/obj  bytes/span  objects  tail waste  max waste  min align</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     1          8        8192     1024           0     87.50%          8</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     2         16        8192      512           0     43.75%         16</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     3         24        8192      341           8     29.24%          8</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     4         32        8192      256           0     21.88%         32</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     5         48        8192      170          32     31.52%         16</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    ......</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    65      27264       81920        3         128     10.00%        128</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    66      28672       57344        2           0      4.91%       4096</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    67      32768       32768        1           0     12.50%       8192</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>sizeclass</p><p>sizeclass 中规格最小 8B，最大 32KB，显而易见这并不是针对 mspan 的规格划分（因为 mspan 最小一个页也有 8192B 的大小），这是针对 “对象” 的划分，即 <strong>Object</strong>。</p><p><strong>object</strong> 是用来存储<strong>一个变量数据</strong>的内存空间，一个 mspan 在<strong>初始化时</strong>，会被切割成一堆等大的 object。<strong>假设</strong> object 的大小是 16B，mspan 大小是 8KB，那么就会把 mspan 分成 512 个object；所谓内存分配，就是分配一个 object 出去。</p><p><strong>spanclass</strong> 是用来记录 mspan 属于哪种规格类型的，具体如图：</p><p><img src="`+l+'" alt="img"></p><ul><li><strong>mcache</strong> —— 是 Go 的线程缓存，它会与线程上的处理器（P）一 一 绑定，主要用来缓存用户程序申请的微小对象。</li></ul><p>mcache有一个长度为136的 *mspan 类型的数组，在<strong>alloc字段</strong>中。</p><p><img src="'+h+`" alt="img"></p><p>（在 Go 1.2 版本前调度器使用的是 <code>GM</code> 模型，将<code>mcache</code> 放在了 <code>M</code> 里，但发现存在诸多问题，期中对于内存这一块存在着巨大的浪费。每个<code>M</code> 都持有 <code>mcache</code> 和 <code>stack alloc</code>，但只有在 <code>M</code> 运行 Go 代码时才需要使用的内存(每个 mcache 可以高达2mb)，当 <code>M</code> 在处于 <code>syscall</code> 或 <code>网络请求</code> 的时候是不需要的，再加上 <code>M</code> 又是允许创建多个的，这就造成了很大的浪费。所以从go 1.3版本开始使用了GPM模型，这样在高并发状态下，每个G只有在运行的时候才会使用到内存，而每个 G 会绑定一个P，所以它们在运行只占用一份 mcache，对于 mcache 的数量就是P 的数量，同时并发访问时也不会产生锁。）</p><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 源码文件路径：runtime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mchche.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Line:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mcache </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    tiny</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">             uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     //&lt;16byte 申请小对象的起始地址</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    tinyoffset</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     //从起始地址tiny开始的偏移量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    local_tinyallocs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     //tiny对象分配的数量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 9</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    alloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">numSpanClasses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 分配的mspan list，其中numSpanClasses=68*2，索引是splanclassId</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    stackcache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_NumStackOrders</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stackfreelist</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     //栈缓存</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    local_largefree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // 大对象释放字节数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    local_nlargefree</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // 释放的大对象数量</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    local_nsmallfree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_NumSizeClasses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 每种规格小对象释放的个数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    flushGen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uint32</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     //扫描计数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>mcache结构</p><p>mcache 中有三个字段组成<strong>微对象分配器</strong>，用于专门管理 16B以下的对象。微分配器只会用于分配<strong>非指针类型的内存</strong>，三个字段中 tiny 会指向堆中的一片内存，tinyoffset 是下一个空闲内存所在的偏移量，最后的 tinyAllocs 会记录内存分配器中分配的对象个数。</p><p>mcache 在初始化时是没有任何 mspan 资源的，alloc 字段中都是空的占位符 emptymspan，而是在使用过程中会动态地申请，不断地去填充 alloc[numSpanClasses]*mspan，通过双向链表连接。</p><p><img src="`+t+`" alt="img"></p><ul><li><strong>mcentral</strong> —— 是内存分配器的中心缓存，与线程缓存不同，<strong>访问中心缓存的内存管理单元需要互斥锁。</strong></li></ul><p>一个 mcentral 对应一种 mspan 规格类型。</p><p>当 mcache 的某个类别 span 的内存被分配光时，它会会通过中心缓存的 runtime.mcentral.cacheSpan 方法获取新的内存管理单元。</p><p>mcentral 的 partial 和 full 都有两个 spanSet 集合，这是为了给GC来使用的，一个集合是已扫描，另一个是未扫描。</p><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 源码文件路径：runtime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mcentral.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Line:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mcentral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     spanclass</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spanClass</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //对应的 spanclass</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     partial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spanSet</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //维护全部空闲的 span 集合</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     full</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spanSet</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //维护存在非空闲的 span 集合</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>mcentral结构</p><p><img src="`+e+'" alt="img"></p><ul><li><strong>mheap</strong> —— 管理整个堆内存。mheap 中有两组非常重要的字段，一个是 <strong>centra</strong>，全局的中心缓存列表，是一个长度为136和数组，数组元素是一个 mcentral 结构。（如上图）另一个是 **arenas，**是一组元素为 heapArena 的二维矩阵，用来管理堆区内存区域。</li></ul><p><img src="'+k+`" alt="img"></p><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 源码文件路径：runtime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mheap.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Line:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">240</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> heapArena </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {   </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    heapArenaPtrScalar</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 用于标记当前这个HeapArena的内存使用情况，1. 对应地址中是否存在过对象、对象中哪些地址包含指针，2. 是否被GC标记过。主要用于GC</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    spans</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pagesPerArena</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mspan</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //  存放heapArena中的span指针地址</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    pageInUse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pagesPerArena</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint8</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 保存哪些spans处于mSpanInUse状态</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    pageMarks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pagesPerArena</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint8</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 保存哪些spans中包含被标记的对象</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    pageSpecials</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pagesPerArena</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint8</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 保存哪些spans是特殊的</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 9</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    checkmarks</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">checkmarksMap</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // debug.gccheckmark state</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    zeroedBase</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uintptr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //该arena第一页的第一个字节地址</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>heapArena结构</p><p>heapArenaPtrScalar 是结构体，里面是原本 heapArena 的 bitmap 字段。</p><p>1个bitmap是8bit，每一个指针大小的内存都会有两个bit分别表示是否应该继续扫描和是否包含指针，这样1个byte就会对应arena区域的四个指针大小的内存。当前HeapArena中的所有Page均会被bitmap所标记，bitmap的主要作用是服务于GC垃圾回收模块。</p><p><img src="`+r+'" alt="img"></p><p>pageInUse 是一个 uint8 类型的数组，长度为1024，共8192位。这个位图用来标记处于使用状态（mSpanInUse）的 mspan 的第一个 page 。</p><p><img src="'+g+'" alt="img"></p><p>pageMarks 和上面类似，标记哪些 span 中存在被标记的对象，在GC清扫阶段会根据这个位图来释放不含标记对象的 mspan。</p><p><img src="'+d+'" alt="img"></p><p>Goroutine、MCache、MCentral、MHeap互相交换的内存单位是不同，<strong>其中协程逻辑层与 mcache 的内存交换单位是 object，mcache 与 mcentral、mcentral 与 mheap 的内存交换单位是 mspan，mheap 与操作系统的内存交换单位是 page</strong>。</p><p>接下来，从宏观图示来展现上述组件之间的关联：</p><p><img src="'+c+'" alt="img"></p><p>最后总结一下内存分配的流程：</p><p><img src="'+o+'" alt="img"></p><h3 id="栈内存" tabindex="-1">栈内存 <a class="header-anchor" href="#栈内存" aria-label="Permalink to &quot;栈内存&quot;">​</a></h3><p>Golang 的栈内存是在堆区里分配的内存，但其管理方式不同。</p><p><img src="'+y+'" alt="img"></p><p>为提高栈分配效率，调度器初始化时，会初始化两个用于栈分配的全局对象：<strong>stackpool</strong> 和 <strong>stackLarge</strong>。（小于32KB使用stackopool，反之使用stackLarge）</p><p><img src="'+F+'" alt="img"></p><p><img src="'+b+'" alt="img"></p><p>和堆内存一样，除了全局栈缓存，每个 P 也有着本地栈缓存。</p><p><img src="'+E+'" alt="img"></p><p>栈内存分配：</p><p><img src="'+m+'" alt="img"></p><h2 id="_3-内存回收-gc" tabindex="-1">3.内存回收（GC） <a class="header-anchor" href="#_3-内存回收-gc" aria-label="Permalink to &quot;3.内存回收（GC）&quot;">​</a></h2><p>Go采用的是<strong>标记清除方式</strong>。当GC开始时，从 root 开始一层层扫描，这里的root取当前所有 goroutine 的栈和全局数据区的变量（主要是这两个地方）。扫描过程中把能被触达的 object 标记出来，那么堆空间未被标记的 object 就是垃圾了（“可达性”近似等于“存活性”的思想）；最后遍历堆空间所有 object 对垃圾（未标记）的object 进行清除，清除完成则表示 GC 完成。 清除的 object 会被放回到 mcache 中以备后续分配使用。</p><ul><li>Go1.1：全程STW（stop-the-world）</li></ul><p>最开始时，Go的整个GC过程都需要STW，因为用户进程如果在GC过程中修改了变量的引用关系，可能导致清理错误。但这样效率低下，浪费大量时间。</p><ul><li>Go1.3：标记STW，清除并行</li></ul><p>STW是为了阻止标记错误，所以只需要在标记过程进行STW即可。</p><ul><li>Go1.5：三色标记法</li></ul><p>为了让标记过程也能并行，Go采用了<strong>三色标记+写屏障</strong>的机制。它的步骤如下：</p><ol><li>GC 开始时，认为所有 object 都是“白色”，即垃圾</li><li>root 区的所有对象变为“灰色”</li><li>遍历所有“灰色”，将所有可达对象变为“灰色”，然后自身变为“黑色”</li><li>循环第3步，直到没有“灰色”。剩余的“黑色”是存活数据，“白色”都是垃圾</li><li>对于“黑色”，如果在标记期间<strong>发生了写操作</strong>，写屏障会在真正赋值前将新对象标记为“灰色”。</li><li>标记过程中，新分配的对象，都会变成“黑色”</li></ol><p>还有一种情况： 标记过程中，堆上的 object 被赋值给了一个栈上指针，导致这个 object 没有被标记到。因为对<strong>栈上指针</strong>进行写入，写屏障是<strong>检测不到</strong>的（实际上并不是做不到，而是代价非常高，写屏障故意没有去管它）。下图展示了整个流程：</p><p><img src="'+C+'" alt="img"></p><p>为了解决这个问题，标记的最后阶段，还会回头重新扫描一下所有的栈空间，确保没有遗漏。而这个过程就需要启动STW了，否则并发场景会使上述问题反复重现。</p><ul><li>Go1.8：Hibrid Write Barrier(混合写屏障)</li></ul><p>三色标记方式，需要再最后重新扫描一遍所有全局变量和goroutie栈空间，如果系统的 goroutine 很多，这个阶段耗时也会比较长，甚至会长达 100ms。毕竟 goroutine 很轻量，大型系统中，上百万的 goroutine 也是常有的事情。</p><p>而混合写屏障，<strong>会在赋值前堆旧数据置灰，在视情况对新值进行置灰</strong>，如图所示：</p><p><img src="'+u+'" alt="img"></p><p>这样就不需要在最后回头重新扫描所有的 goroutine 的栈空间了，这使得整个 GC过程STW几乎可以忽略不计。</p><p>但也有一点小小的代价，就是上图中如果 C 没有赋值给 L，用户执行 B.next = nil后，C 的确变成了垃圾，而我们却把它置灰了，使得C只能等到下一轮 GC 才能被回收了。而GC 过程创建的新对象直接标记成黑色也会带来这个问题，即使新 object 在扫描结束前变成了垃圾，这次 GC 也不会回收它，只能等下轮。</p><p>最后总结一下GC的流程图，如下：</p><p><img src="'+A+`" alt="img"></p><h2 id="_4-函数多返回值" tabindex="-1">4.函数多返回值 <a class="header-anchor" href="#_4-函数多返回值" aria-label="Permalink to &quot;4.函数多返回值&quot;">​</a></h2><h2 id="_5-异常处理" tabindex="-1">5.异常处理 <a class="header-anchor" href="#_5-异常处理" aria-label="Permalink to &quot;5.异常处理&quot;">​</a></h2><p>golang不支持try...catch这样的结构化的异常解决方式。golang提倡的异常处理方式是：</p><ul><li>普通异常：被调用方返回error对象，调用方判断error对象。</li><li>严重异常：指的是中断性panic（比如除0），使用defer...recover...panic机制来捕获处理。严重异常一般由golang内部自动抛出，不需要用户主动抛出，避免传统try...catch写得到处都是的情况。当然，用户也可以使用panic(&#39;xxxx&#39;)主动抛出，只是这样就使这一套机制退化成结构化异常机制了。</li></ul><h2 id="_6-强类型语言" tabindex="-1">6.强类型语言 <a class="header-anchor" href="#_6-强类型语言" aria-label="Permalink to &quot;6.强类型语言&quot;">​</a></h2><p>作为强类型语言，隐式的类型转换是不被golang允许的。</p><p>类型转换可以通过<strong>强制类型转换</strong>和<strong>类型断言：</strong></p><p>当变量和指针类型不匹配时，都可以使用*type（var_name）*进行强制类型转换（如下）。</p><p>强制类型转换</p><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 4     </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fmt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 5     </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unsafe</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 9</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5.6</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     //fmt.Println (a * b)    //此处不能进行隐式转换</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     fmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     //var d *int64 = (*int64)(p)    //指针类型的强制转换需要unsafe包</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*int64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*int64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(unsafe.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pointer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     fmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">19</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>golang中的 <em><strong>interface{}</strong></em> 即 <strong>any</strong> 可以代表所有类型，包括基本类型string、int、int64，以及自定义的 struct 类型。因此当我们想要使用这个变量时，我们需要判断变量的类型，即进行类型断言。</p><ul><li>类型断言的语法：<em><strong>变量b :=变量a.(类型)</strong></em></li></ul><p>断言是否正确，断言之后执行什么操作，具体实施可以通过配合 if...else 或 switch 来实现。</p><h2 id="_7-其他特性" tabindex="-1">7.其他特性 <a class="header-anchor" href="#_7-其他特性" aria-label="Permalink to &quot;7.其他特性&quot;">​</a></h2><ol><li><strong>defer机制</strong>：在Go语言中，提供关键字defer，可以通过该关键字指定需要延迟执行的逻辑体，即在函数体return前或出现panic时执行。这种机制非常适合善后逻辑处理，比如可以尽早避免可能出现的资源泄漏问题。</li><li>编程规范：GO语言的编程规范强制集成在语言中，比如明确规定花括号摆放位置，强制要求一行一句，不允许导入没有使用的包，不允许定义没有使用的变量，提供gofmt工具强制格式化代码等等。</li><li>“包”的概念：和python一样，把相同功能的代码放到一个目录，称之为包。包可以被其他包引用。main包是用来生成可执行文件，每个程序只有一个main包。包的主要用途是提高代码的可复用性。通过package可以引入其他包。</li></ol>`,102),_=[D];function f(v,G,P,S,x,q){return a(),i("div",null,_)}const T=s(B,[["render",f]]);export{M as __pageData,T as default};
